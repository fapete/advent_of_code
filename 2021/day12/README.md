Yet another messy solution...

Basic idea: construct all valid paths from u to v by recursively getting all valid paths from the neighbourhood of u to v and prepending u to those paths. Then filter for the paths starting at "start" and ending at "end". this was still sort of ok, even though the main workhorse function "allValidPaths'" is already quite hard to read.

Part 2 is rather messy: We do the above, but for every small cave we change the graph such that this cave is designated as "allowed to visit twice" and use boolean conditionals in "allValidPaths'" to check whether this has already happened, really making the function completely unreadable. We also need to convert internal graph vertices back into cave here (and replace the "allowed to visit twice" marker with "Small" again), as otherwise different paths may have the same representation. This is really slow in addition to being unreadable...